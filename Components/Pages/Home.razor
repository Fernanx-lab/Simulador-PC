@page "/"
@rendermode InteractiveServer
@using System.Net.Http.Json
@using System.Text.Json
@using ProjetoSimuladorPC.Utilidades
@inject SimulationState Simulation
@inject HttpClient Http
@inject SimulationEngine Engine
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Mini Computador — Painel</PageTitle>

<div class="panel">
    <header class="panel-header">
        <h1>Mini Computador</h1>
        <div class="controls">
            <button class="btn" @onclick="AdvanceCycleAsync" disabled="@isLoading">Avançar ciclo</button>
            <button class="btn" @onclick="RefreshAsync" disabled="@isLoading">Atualizar</button>
            <label class="auto">
                <input type="checkbox" @bind="AutoAdvance" />
                Auto (interval ms)
            </label>
            <input type="number" class="small" @bind="AutoMs" min="50" />
        </div>
    </header>

    <section class="status-bar">
        <div>Ciclo: <strong>@snapshot?.CicloAtual</strong></div>
        <div>Timestamp: <strong>@(snapshot?.TimestampUtc.ToLocalTime().ToString("HH:mm:ss.fff") ?? "-")</strong></div>
        <div>Clock: <strong>@config?.ClockHz</strong> Hz</div>
    </section>

    <aside style="margin:12px 0; padding:10px; background:rgba(255,255,255,0.02); border-radius:6px;">
        <h3>Configurações Atuais</h3>
        @if (config is not null)
        {
            <div style="font-family:ui-monospace,Consolas,monospace; font-size:0.95rem;">
                <div><strong>Clock:</strong> @config.ClockHz Hz</div>
                <div><strong>Cache L1:</strong> @config.L1Size · assoc.@config.L1Assoc · linha @config.L1LineSize</div>
                <div><strong>Write Policy:</strong> @config.L1WritePolicy @if(config.L1WriteAlloc){<span>(Write-Alloc)</span>}</div>
                <div><strong>Bus:</strong> largura @config.BusWidthBytes bytes · wait @config.BusWaitStates · @config.BusArbitration</div>
                <div><strong>Timer Period:</strong> @config.TimerPeriodCycles ciclos</div>
                <div><strong>DMA Burst Len:</strong> @config.DmaBurstLen</div>
                <div><strong>MMIO Bases:</strong> Timer=0x@config.TimerBase:X8 Console=0x@config.ConsoleBase:X8 DMA=0x@config.DmaBase:X8 PIC=0x@config.PicBase:X8</div>
            </div>
        }
        else
        {
            <div>(configuração não disponível)</div>
        }
    </aside>

    <main class="grid">
        <article class="card cpu">
            <h2>CPU</h2>
            @if (snapshot is not null)
            {
                <dl>
                    <dt>PC</dt><dd>@snapshot.Cpu.ContadorPrograma</dd>
                    <dt>Accum</dt><dd>@snapshot.Cpu.Acumulador</dd>
                    <dt>Operação</dt><dd>@snapshot.Cpu.OperacaoAtual</dd>
                    <dt>Último acesso</dt><dd>@snapshot.Cpu.UltimoEnderecoAcesso</dd>
                    <dt>Interrupções</dt><dd>@(snapshot.Cpu.InterrupcaoHabilitada ? "ativada" : "desativada")</dd>
                    <dt>Parado</dt><dd>@(snapshot.Cpu.Parado ? "sim" : "não")</dd>
                </dl>
            }
            else
            {
                <p>Carregando...</p>
            }
        </article>

        <article class="card cache">
            <h2>Cache</h2>
            @if (snapshot is not null)
            {
                <div class="metrics">
                    <div>Leituras: <strong>@snapshot.Cache.Reads</strong></div>
                    <div>Escritas: <strong>@snapshot.Cache.Writes</strong></div>
                    <div>Hits: <strong>@snapshot.Cache.Hits</strong></div>
                    <div>Misses: <strong>@snapshot.Cache.Misses</strong></div>
                </div>
                <div class="rates">
                    <div>Hit rate: <strong>@(snapshot.Cache.HitRate.ToString("P2"))</strong></div>
                    <div>Miss rate: <strong>@(snapshot.Cache.MissRate.ToString("P2"))</strong></div>
                </div>
                <div class="meta">
                    <small>@snapshot.Cache.CacheSizeBytes bytes · linha @snapshot.Cache.BlockSizeBytes · assoc. @snapshot.Cache.Associativity</small>
                </div>
            }
        </article>

        <article class="card ram">
            <h2>Memória (preview)</h2>
            @if (snapshot is not null)
            {
                <div class="ram-info">
                    <div>Tamanho: <strong>@snapshot.Ram.TamanhoEmBytes</strong> bytes (@snapshot.Ram.TamanhoEmMB MB)</div>
                    <div>Preview em @snapshot.Ram.PreviewAddress (disponível: @snapshot.Ram.PreviewAvailable)</div>
                </div>

                <pre class="hex">
@foreach (var line in GetRamLines(snapshot.Ram.Preview, snapshot.Ram.PreviewAddress, 16))
{
    @line
}
                </pre>
            }
        </article>

        <article class="card dma">
            <h2>DMA</h2>
            @if (snapshot is not null)
            {
                <div>Origem: <strong>@snapshot.Dma.Origem</strong></div>
                <div>Destino: <strong>@snapshot.Dma.Destino</strong></div>
                <div>Tamanho: <strong>@snapshot.Dma.Tamanho</strong></div>
                <div>Progresso: <strong>@snapshot.Dma.BytesTransferidos</strong> / @snapshot.Dma.Tamanho</div>

                <div class="progress">
                    <div class="bar" style="width:@(snapshot.Dma.Tamanho > 0 ? (snapshot.Dma.BytesTransferidos * 100.0 / snapshot.Dma.Tamanho) : 0)%"></div>
                </div>

                <div class="dma-msg">@snapshot.Dma.Mensagem</div>
            }

            <div style="margin-top:10px;">
                <label>Origem: <input type="number" class="small" @bind="dmaOrigem" /></label>
                <label style="margin-left:8px">Destino: <input type="number" class="small" @bind="dmaDestino" /></label>
                <label style="margin-left:8px">Tamanho: <input type="number" class="small" @bind="dmaTamanho" min="1" /></label>
                <label style="margin-left:8px">Delay ms: <input type="number" class="small" @bind="dmaDelayMs" min="0" /></label>
                <button class="btn" @onclick="StartDmaClicked" disabled="@isDmaRunning">Iniciar DMA</button>
            </div>
        </article>
    </main>

    <footer class="panel-footer">
        <small>Apresente com confiança — dados vindos de <code>SimulationState</code>.</small>
        @if (!string.IsNullOrEmpty(LastError))
        {
            <div style="margin-top:8px;color:#ffb3b3;">Erro: @LastError</div>
        }
    </footer>
</div>

<style>
    .panel {
        font-family: ui-monospace, Menlo, "Courier New", monospace;
        color: #e6fff2;
        background: linear-gradient(180deg, #071014 0%, #071018 100%);
        padding: 18px;
        height: 100%;
    }

    .panel-header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
    .panel-header h1 { margin:0; font-size:22px; color:#7ef3b7; }
    .controls { display:flex; gap:8px; align-items:center; }
    .btn { background:#143; color:#cffeeb; border:0; padding:6px 10px; border-radius:6px; cursor:pointer; }
    .small { width:80px; padding:4px; border-radius:4px; }

    .status-bar { display:flex; gap:20px; margin-top:12px; color:#9be7c4; }

    .grid { display:grid; grid-template-columns: repeat(2, 1fr); gap:12px; margin-top:16px; }
    .card { background: rgba(255,255,255,0.02); padding:12px; border-radius:8px; min-height:140px; box-shadow: 0 6px 18px rgba(0,0,0,0.5); }
    .card h2 { margin-top:0; color:#9df6c8; }

    .metrics { display:flex; gap:8px; flex-wrap:wrap; }
    .rates { margin-top:8px; color:#cdefd6; }
    .meta { margin-top:8px; color:#9aaea0; font-size:12px; }

    .ram-info { margin-bottom:8px; color:#d9f3e1; }
    pre.hex { background:#021314; color:#9ff5d1; padding:8px; border-radius:6px; overflow:auto; max-height:200px; }

    .progress { background:#00332b; height:14px; border-radius:8px; margin:8px 0; overflow:hidden; }
    .bar { height:100%; background:linear-gradient(90deg,#57e6a1,#008f66); width:0%; transition:width .3s ease; }

    .dma-msg { font-size:12px; color:#bfead0; margin-top:6px; }

    footer.panel-footer { margin-top:12px; color:#7ea38f; }
</style>

@code {
    SimulationSnapshot? snapshot;
    Configuracoes? config;

    string? LastError;
    bool isLoading = false;

    // DMA UI state
    int dmaOrigem = 0;
    int dmaDestino = 0;
    int dmaTamanho = 16;
    int dmaDelayMs = 10;
    bool isDmaRunning = false;

    // Auto properties: AutoAdvance controla o Engine.StartAuto/StopAuto.
    private bool _autoAdvance;
    private bool AutoAdvance
    {
        get => _autoAdvance;
        set
        {
            _autoAdvance = value;
            try
            {
                if (_autoAdvance) Engine?.StartAuto(Math.Max(1, AutoMs));
                else Engine?.StopAuto();
            }
            catch (Exception ex)
            {
                LastError = $"Erro ao alternar Auto: {ex.Message}";
            }
        }
    }

    private int _autoMs = 500;
    private int AutoMs
    {
        get => _autoMs;
        set
        {
            _autoMs = value;
            // se Auto estiver ativo, reinicia com novo intervalo
            if (AutoAdvance)
            {
                try { Engine?.StartAuto(Math.Max(1, _autoMs)); }
                catch (Exception ex) { LastError = $"Erro ao atualizar intervalo Auto: {ex.Message}"; }
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        Simulation.StateChanged += OnSimulationChanged;
        await RefreshAsync();
        // inicializa config local a partir do serviço
        config = Simulation.Config ?? new Configuracoes();
        if (AutoAdvance) Engine?.StartAuto(Math.Max(1, AutoMs));
    }

    void OnSimulationChanged(object? s, EventArgs e)
    {
        // atualiza snapshot e config reativamente — prioriza snapshot local para evitar round-trip HTTP
        InvokeAsync(() =>
        {
            try
            {
                // leitura local e rápida do snapshot (garante que mudanças em RAM/DMA apareçam imediatamente)
                snapshot = Simulation.GetSnapshot(0, 32);
                config = Simulation.Config ?? new Configuracoes();
                StateHasChanged();
            }
            catch
            {
                // fallback para a versão assíncrona/HTTP caso algo falhe
                _ = RefreshAsync();
            }
        });
    }

    async Task StartDmaClicked()
    {
        LastError = null;
        try
        {
            isDmaRunning = true;
            StateHasChanged();
            // chama o Engine que por sua vez invoca DMA.ExecutarTransferenciaAsync(...)
            await Engine.StartDmaAsync(dmaOrigem, dmaDestino, dmaTamanho, dmaDelayMs);
            // força uma atualização quando a transferência terminar (os eventos já atualizam durante a transferência)
            await RefreshAsync();
        }
        catch (Exception ex)
        {
            LastError = $"Falha ao iniciar DMA: {ex.Message}";
        }
        finally
        {
            isDmaRunning = false;
            StateHasChanged();
        }
    }

    async Task RefreshAsync()
    {
        isLoading = true;
        LastError = null;
        try
        {
            snapshot = await Http.GetFromJsonAsync<SimulationSnapshot>($"api/simulation/snapshot?ramPreviewAddress=0&ramPreviewLength=32");
            // se o snapshot veio do servidor, mantenha config também pelo HTTP (opcional)
            if (snapshot is not null) await LogSnapshotToConsole();
        }
        catch (Exception ex)
        {
            // fallback local: ler diretamente do serviço caso o HTTP falhe
            try
            {
                snapshot = Simulation.GetSnapshot(0, 32);
                config = Simulation.Config ?? new Configuracoes();
                if (snapshot is not null) await LogSnapshotToConsole();
            }
            catch (Exception inner)
            {
                LastError = $"Falha ao atualizar: {inner.Message}";
            }
            // registra erro visível
            if (LastError is null)
            {
                LastError = $"Falha ao buscar snapshot via HTTP: {ex.Message}";
            }
        }
        finally
        {
            isLoading = false;
        }
    }

    async Task AdvanceCycleAsync()
    {
        isLoading = true;
        LastError = null;
        try
        {
            var response = await Http.PostAsync($"api/simulation/advance?delta=1", null);
            response.EnsureSuccessStatusCode();
            await RefreshAsync();
        }
        catch (Exception ex)
        {
            try
            {
                Engine?.AdvanceOneCycle();
                await RefreshAsync();
            }
            catch (Exception inner)
            {
                LastError = $"Falha ao avançar ciclo via Engine: {inner.Message}";
            }

            if (LastError is null)
            {
                LastError = $"Falha HTTP ao avançar ciclo: {ex.Message}";
            }
        }
        finally
        {
            isLoading = false;
        }
    }

    // --- novo: loga snapshot e partes no console do navegador via IJSRuntime ---
    async Task LogSnapshotToConsole()
    {
        if (snapshot is null) return;

        try
        {
            var opts = new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
            };

            // log principal (string grande): evita problemas com objetos circulares serializando snapshot parcial
            var json = JsonSerializer.Serialize(snapshot, opts);
            await JS.InvokeVoidAsync("console.log", "SimulationSnapshot:", json);

            // logs separados para facilitar leitura
            await JS.InvokeVoidAsync("console.log", "CPU:", JsonSerializer.Serialize(snapshot.Cpu, opts));
            await JS.InvokeVoidAsync("console.log", "Cache:", JsonSerializer.Serialize(snapshot.Cache, opts));
            await JS.InvokeVoidAsync("console.log", "DMA:", JsonSerializer.Serialize(snapshot.Dma, opts));
            await JS.InvokeVoidAsync("console.log", "RAM Preview:", JsonSerializer.Serialize(snapshot.Ram, opts));
        }
        catch (Exception ex)
        {
            // erros de serialização aparecem no console do navegador
            await JS.InvokeVoidAsync("console.error", "Erro ao serializar snapshot:", ex.Message);
        }
    }

    IEnumerable<string> GetRamLines(byte[] data, int baseAddr, int cols)
    {
        if (data == null || data.Length == 0)
        {
            yield return "(sem preview)";
            yield break;
        }

        for (int i = 0; i < data.Length; i += cols)
        {
            var slice = data.Skip(i).Take(cols).ToArray();
            var addr = baseAddr + i;
            var hex = string.Join(" ", slice.Select(b => b.ToString("X2")));
            yield return $"{addr:X8}: {hex}";
        }
    }

    public void Dispose()
    {
        Simulation.StateChanged -= OnSimulationChanged;
        try { Engine?.StopAuto(); } catch { }
    }
}
